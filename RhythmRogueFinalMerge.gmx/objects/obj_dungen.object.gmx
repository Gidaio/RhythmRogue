<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>rm_dim = 0;
boss_room = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var map, segment_size, i, j, rm_width, rm_height, rm_xoffset, rm_yoffset, doorx, doory, door1x, door1y, door2x, door2y, turnpoint, stair_x, stair_y, player_x, player_y;

boss_room = false;

ds_list_shuffle(obj_timekeeper.attackList);
obj_timekeeper.floornumber+=1;
obj_timekeeper.difficulty=min(2*round((60-60/(obj_timekeeper.floornumber/2+1))/2), 58);

if(instance_exists(obj_wall))
{
    with(obj_wall)
        instance_destroy();
}
if(instance_exists(obj_stairs))
{
    with(obj_stairs)
        instance_destroy();
}
if(instance_exists(obj_darkness))
{
    with(obj_darkness)
        instance_destroy();
}
if(instance_exists(obj_enemyparent))
{
    with(obj_enemyparent)
        instance_destroy();
        with(obj_player)
            max_hp -= 1;
}

if(irandom(5) == 5&amp;&amp;obj_timekeeper.floornumber&gt;2) {
    rm_dim = 1;
    boss_room = true; }
else if(obj_timekeeper.difficulty &lt;= 16)
    rm_dim = 2; //get_integer("Room dimensions?", 3);
else if(obj_timekeeper.difficulty &lt;= 36)
    rm_dim = 3;
else
    rm_dim = 4;


map = ds_grid_create(40, 40);
segment_size = floor(40 / rm_dim)
show_debug_message("Segment size: " + string(segment_size));

if(!boss_room)
{
    rm_dim--;
    
    for(i = 0; i &lt;= rm_dim; i++;)
    {
        for(j = 0; j &lt;= rm_dim; j++;)
        {
            //make rooms
            //rooms are a minimum of 3x3, maximum of segment_size - 1
            rm_width = irandom(segment_size - 4) + 2;
            rm_height = irandom(segment_size - 4) + 2;
            rm_xoffset = irandom(segment_size - rm_width - 1);
            rm_yoffset = irandom(segment_size - rm_height - 1);
            ds_grid_set_region(map, i * segment_size + rm_xoffset, j * segment_size + rm_yoffset, i * segment_size + rm_xoffset + rm_width, j * segment_size + rm_yoffset + rm_height, 1);
            
            //figure out door locations
            //each door has a number indicating which side of the room it's on
            //2 - right
            //3 - up
            //4 - left
            //5 - down
            switch(i)
            {
                case(0):
                {
                    do{
                        doory = irandom(rm_height) + rm_yoffset;
                        show_debug_message('1');
                    }until(ds_grid_get(map, rm_xoffset + rm_width, j * segment_size + doory) == 1)
                    ds_grid_set(map, rm_xoffset + rm_width, j * segment_size + doory, 2);
                    break;
                }
                case(rm_dim):
                {
                    do{
                        doory = irandom(rm_height) + rm_yoffset;
                        show_debug_message('4');
                    }until(ds_grid_get(map, rm_xoffset + segment_size * rm_dim, j * segment_size + doory) == 1)
                    ds_grid_set(map, rm_xoffset + segment_size * rm_dim, j * segment_size + doory, 4);
                    break;
                }
                default:
                {
                    do{
                        doory = irandom(rm_height) + rm_yoffset;
                        show_debug_message('2');
                    }until(ds_grid_get(map, rm_xoffset + rm_width + i * segment_size, j * segment_size + doory) == 1)
                    ds_grid_set(map, rm_xoffset + rm_width + i * segment_size, j * segment_size + doory, 2);
                    do{
                        doory = irandom(rm_height) + rm_yoffset;
                        show_debug_message('3');
                    }until(ds_grid_get(map, rm_xoffset + i * segment_size, j * segment_size + doory) == 1)
                    ds_grid_set(map, rm_xoffset + i * segment_size, j * segment_size + doory, 4);
                    break;
                }
            }
            switch(j)
            {
                case(0):
                {
                    do{
                        doorx = irandom(rm_width) + rm_xoffset;
                        show_debug_message('5');
                    }until(ds_grid_get(map, i * segment_size + doorx, rm_yoffset + rm_height) == 1)
                    ds_grid_set(map, i * segment_size + doorx, rm_yoffset + rm_height, 5);
                    break;
                }
                case(rm_dim):
                {
                    do{
                        doorx = irandom(rm_width) + rm_xoffset;
                        show_debug_message('8');
                    }until(ds_grid_get(map, i * segment_size + doorx, rm_yoffset + segment_size * rm_dim) == 1)
                    ds_grid_set(map, i * segment_size + doorx, rm_yoffset + segment_size * rm_dim, 3);
                    break;
                }
                default:
                {
                    do{
                        doorx = irandom(rm_width) + rm_xoffset;
                        show_debug_message('6');
                    }until(ds_grid_get(map, i * segment_size + doorx, rm_yoffset + rm_height + j * segment_size) == 1)
                    ds_grid_set(map, i * segment_size + doorx, rm_yoffset + rm_height + j * segment_size, 5);
                    do{
                        doorx = irandom(rm_width) + rm_xoffset;
                        show_debug_message('7');
                    }until(ds_grid_get(map, i * segment_size + doorx, rm_yoffset + j * segment_size) == 1)
                    ds_grid_set(map, i * segment_size + doorx, rm_yoffset + j * segment_size, 3);
                    break;
                }
            }
        }
    }
    
    //draw hallways
    for(i = 0; i &lt;= rm_dim; i++)
    {
        for(j = 0; j &lt;= rm_dim; j++)
        {
            //show_debug_message("i:" + string(i) + " j:" + string(j) + " x1:" + string(i * 10) + " x2:" + string(i * 10 + 9) + " y1:" + string(j * 10) + " y2:" + string(j * 10 + 9));
            if(i &lt; rm_dim)
            {
                if(ds_grid_value_exists(map, i * segment_size, j * segment_size, i * segment_size + segment_size - 1, j * segment_size + segment_size - 1, 2))
                {
                    if(ds_grid_value_exists(map, i * segment_size + segment_size, j * segment_size, i * segment_size + segment_size * 2 - 1, j * segment_size + segment_size - 1, 4))
                    {
                        door1x = ds_grid_value_x(map, i * segment_size, j * segment_size, i * segment_size + segment_size - 1, j * segment_size + segment_size - 1, 2);
                        door1y = ds_grid_value_y(map, i * segment_size, j * segment_size, i * segment_size + segment_size - 1, j * segment_size + segment_size - 1, 2);
                        door2x = ds_grid_value_x(map, i * segment_size + segment_size, j * segment_size, i * segment_size + segment_size * 2 - 1, j * segment_size + segment_size - 1, 4);
                        door2y = ds_grid_value_y(map, i * segment_size + segment_size, j * segment_size, i * segment_size + segment_size * 2 - 1, j * segment_size + segment_size - 1, 4);
                        turnpoint = floor((door1x + door2x) / 2);
                        ds_grid_set_region(map, door1x, door1y, turnpoint, door1y, 1);
                        ds_grid_set_region(map, turnpoint, door1y, turnpoint, door2y, 1);
                        ds_grid_set_region(map, turnpoint, door2y, door2x, door2y, 1);
                    }
                }
            }
            if(j &lt; rm_dim)
            {
                if(ds_grid_value_exists(map, i * segment_size, j * segment_size, i * segment_size + segment_size - 1, j * segment_size + segment_size - 1, 5))
                {
                    if(ds_grid_value_exists(map, i * segment_size, j * segment_size + segment_size, i * segment_size + segment_size - 1, j * segment_size + segment_size * 2 - 1, 3))
                    {
                        door1x = ds_grid_value_x(map, i * segment_size, j * segment_size, i * segment_size + segment_size - 1, j * segment_size + segment_size - 1, 5);
                        door1y = ds_grid_value_y(map, i * segment_size, j * segment_size, i * segment_size + segment_size - 1, j * segment_size + segment_size - 1, 5);
                        door2x = ds_grid_value_x(map, i * segment_size, j * segment_size + segment_size, i * segment_size + segment_size - 1, j * segment_size + segment_size * 2 - 1, 3);
                        door2y = ds_grid_value_y(map, i * segment_size, j * segment_size + segment_size, i * segment_size + segment_size - 1, j * segment_size + segment_size * 2 - 1, 3);
                        turnpoint = floor((door1y + door2y) / 2);
                        ds_grid_set_region(map, door1x, door1y, door1x, turnpoint, 1);
                        ds_grid_set_region(map, door1x, turnpoint, door2x, turnpoint, 1);
                        ds_grid_set_region(map, door2x, turnpoint, door2x, door2y, 1);
                    }
                }
            }
        }
    }
    
    rm_dim++;
        
    for(i = 0; i &lt; rm_dim * segment_size; i++;)
    {
        for(j = 0; j &lt; rm_dim * segment_size; j++;)
        {
            if(ds_grid_get(map, i, j) == 0)
                instance_create(i * 16 + 8, j * 16 + 8, obj_wall);
        }
    }
    
    do
    {
        stair_x = irandom(39);
        stair_y = irandom(39);
    } until(ds_grid_get(map, stair_x, stair_y))
    instance_create(stair_x * 16 + 8, stair_y * 16 + 8, obj_stairs);
    
    do
    {
        player_x = irandom(39);
        player_y = irandom(39);
    } until(ds_grid_get(map, player_x, player_y))
    obj_player.x = player_x * 16 + 8;
    obj_player.y = player_y * 16 + 8;
}

if(boss_room)
{
    bossX = 8 + irandom(39) * 16;
    bossY = 8 + irandom(39) * 16;
    instance_create(bossX, bossY, obj_spawnboss);
    instance_create(bossX, bossY, obj_stairs);
    do{
        obj_player.x = 8 + irandom(39) * 16;
        obj_player.y = 8 + irandom(39) * 16;
    } until(point_distance(obj_player.x, obj_player.y, bossX, bossY) &gt; 64);
}

for(i = 0; i &lt; 40; i++;)
{
    for(j = 0; j &lt; 40; j++;)
    {
        instance_create(i * 16 + 8, j * 16 + 8, obj_darkness);
    }
}

for(i = 0; i &lt; rm_dim * segment_size; i++;)
{
    instance_create(i * 16 + 8, -8, obj_wall);
    instance_create(i * 16 + 8, rm_dim * segment_size * 16 + 8, obj_wall);
}
for(j = 0; j &lt; rm_dim * segment_size; j++;)
{
    instance_create(-8, j * 16 + 8, obj_wall);
    instance_create(rm_dim * segment_size * 16 + 8, j * 16 + 8, obj_wall);
}

ds_grid_destroy(map);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var spawn_x, spawn_y;
if(obj_timekeeper.attackListIndex == 3 &amp;&amp; !boss_room) {
    do {
        spawn_x = irandom(39) * 16 + 8;
        spawn_y = irandom(39) * 16 + 8; } until(!collision_point(spawn_x, spawn_y, obj_wall, false, true) &amp;&amp; point_distance(spawn_x, spawn_y, obj_player.x, obj_player.y) &gt; 80);
    switch(irandom(3)) {
        case(0): {
            instance_create(spawn_x, spawn_y, obj_enemyyellow);
            break; }
        case(1): {
            instance_create(spawn_x, spawn_y, obj_enemygreen);
            break; }
        case(2): {
            instance_create(spawn_x, spawn_y, obj_enemyblue);
            break; }
        case(3): {
            instance_create(spawn_x, spawn_y, obj_enemyred);
            break; } } }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(joystick_check_button(1, global.stairsbutton) || keyboard_check(vk_space) &amp;&amp; obj_player.x == obj_stairs.x &amp;&amp; obj_player.y == obj_stairs.y &amp;&amp; obj_timekeeper.alarm[0] == 1)
    alarm[3] = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
